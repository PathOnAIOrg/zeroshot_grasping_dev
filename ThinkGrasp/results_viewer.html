<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ThinkGrasp Results Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            text-align: center;
            color: white;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .main-container {
            display: flex;
            height: calc(100vh - 100px);
            gap: 20px;
            padding: 20px;
        }

        .sidebar {
            width: 300px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .sidebar h3 {
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }

        .result-item {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .result-item:hover {
            background: #e3f2fd;
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .result-item.active {
            background: #667eea;
            color: white;
            border-color: #5a6fd8;
        }

        .result-timestamp {
            font-weight: bold;
            font-size: 0.9em;
        }

        .result-preview {
            font-size: 0.8em;
            margin-top: 5px;
            opacity: 0.7;
        }

        .content-area {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #666;
            font-size: 1.2em;
        }

        .viewer-container {
            width: 100%;
            height: 500px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            background: #f5f5f5;
            margin-bottom: 20px;
        }

        .viewer-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .viewer-btn {
            padding: 8px 12px;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }

        .viewer-btn:hover {
            background: rgba(90, 111, 216, 0.9);
        }

        .viewer-btn.active {
            background: rgba(255, 107, 107, 0.9);
        }

        .viewer-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .info-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .info-card h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .info-card pre {
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.9em;
            overflow-x: auto;
        }

        .refresh-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .refresh-btn:hover {
            background: #218838;
        }

        .stats-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            flex: 1;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-box h3 {
            font-size: 1.5em;
            margin-bottom: 5px;
        }

        .error-message {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ü§ñ ThinkGrasp Results Viewer</h1>
        <p>Interactive 3D Visualization and Analysis Tool</p>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <button class="refresh-btn" onclick="loadResultsList()">üîÑ Refresh Results</button>
            <h3>üìÇ Available Results</h3>
            <div id="results-list">
                <div class="loading">Loading results...</div>
            </div>
        </div>

        <div class="content-area">
            <div id="content">
                <div class="loading">
                    <h2>Welcome to ThinkGrasp Results Viewer</h2>
                    <p>Select a result from the sidebar to view detailed analysis and 3D visualization.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let pointCloud, gripperMesh, allGraspMeshes = [];
        let showPointCloud = true, showGripper = true, showAllGrasps = false, wireframeMode = false;
        let currentResult = null;
        let currentStep = null;
        let availableSteps = [];
        
        // Multi-panel variables
        let panels = {};
        let isMultiPanelMode = false;
        let cachedPointCloudData = {}; // Cache point cloud data to avoid reloading
        let autoSync = false; // Auto-sync camera views

        // Load list of available results
        async function loadResultsList() {
            try {
                const response = await fetch('/list_results');
                const data = await response.json();
                
                const listContainer = document.getElementById('results-list');
                
                if (data.timestamps && data.timestamps.length > 0) {
                    listContainer.innerHTML = '';
                    data.timestamps.forEach(timestamp => {
                        const item = document.createElement('div');
                        item.className = 'result-item';
                        item.onclick = () => loadResult(timestamp);
                        
                        const date = parseTimestamp(timestamp);
                        item.innerHTML = `
                            <div class="result-timestamp">${timestamp}</div>
                            <div class="result-preview">${date}</div>
                        `;
                        
                        listContainer.appendChild(item);
                    });
                } else {
                    listContainer.innerHTML = '<div class="error-message">No results found. Run some grasp detection first!</div>';
                }
            } catch (error) {
                console.error('Error loading results list:', error);
                document.getElementById('results-list').innerHTML = '<div class="error-message">Error loading results list.</div>';
            }
        }

        // Parse timestamp into readable date
        function parseTimestamp(timestamp) {
            const year = timestamp.substr(0, 4);
            const month = timestamp.substr(4, 2);
            const day = timestamp.substr(6, 2);
            const hour = timestamp.substr(9, 2);
            const minute = timestamp.substr(11, 2);
            const second = timestamp.substr(13, 2);
            
            return `${year}-${month}-${day} ${hour}:${minute}:${second}`;
        }

        // Load and display a specific result
        async function loadResult(timestamp) {
            currentResult = timestamp;
            
            // Clear cache when switching results
            cachedPointCloudData = {};
            
            // Update active item in sidebar
            document.querySelectorAll('.result-item').forEach(item => item.classList.remove('active'));
            event.target.closest('.result-item').classList.add('active');
            
            // Show loading
            document.getElementById('content').innerHTML = '<div class="loading">Loading result data...</div>';
            
            try {
                // Load all result files and steps
                const [
                    openaiResponse,
                    finalResults,
                    graspPoses,
                    stepsData
                ] = await Promise.all([
                    loadTextFile(timestamp, 'openai_response.txt'),
                    loadJsonFile(timestamp, 'final_grasp_results.json'),
                    loadJsonFile(timestamp, 'grasp_poses.npy', false), // Optional file
                    loadSteps(timestamp)
                ]);

                availableSteps = stepsData?.steps || [];
                
                // Determine if this is a legacy result
                const isLegacyResult = !availableSteps || availableSteps.length === 0;

                // Create content
                const content = `
                    <h2>üìä Result Analysis - ${parseTimestamp(timestamp)} ${isLegacyResult ? '(Legacy)' : ''}</h2>
                    
                    ${isLegacyResult ? '<div class="info-card" style="margin-bottom: 15px;"><h4>‚ÑπÔ∏è Legacy Result</h4><p>This result was generated before the enhanced visualization system. Some 3D features may be limited.</p></div>' : ''}
                    
                    <div class="stats-row">
                        <div class="stat-box">
                            <h3>${finalResults?.action_index ?? 'N/A'}</h3>
                            <p>Selected Action</p>
                        </div>
                        <div class="stat-box">
                            <h3>${finalResults?.position_xyz ? '‚úì' : '‚úó'}</h3>
                            <p>Grasp Position</p>
                        </div>
                        <div class="stat-box">
                            <h3>${finalResults?.depth ?? 'N/A'}</h3>
                            <p>Grasp Depth</p>
                        </div>
                    </div>

                    <div id="steps-selector" style="margin-bottom: 15px; display: none;">
                        <h4>üîÑ Processing Steps:</h4>
                        <div id="steps-buttons"></div>
                        <div style="margin-top: 10px;">
                            <button class="viewer-btn" onclick="showSingleView()" id="single-view-btn">üì± Single View</button>
                            <button class="viewer-btn" onclick="showMultiPanel()" id="multi-panel-btn">üóÇÔ∏è Multi-Panel</button>
                        </div>
                    </div>

                    <div class="viewer-container" id="threejs-viewer">
                        <div class="viewer-controls">
                            <button class="viewer-btn" onclick="resetCamera()">üîÑ Reset</button>
                            <button class="viewer-btn" id="toggle-points" onclick="togglePointCloud()">üëÅÔ∏è Points</button>
                            <button class="viewer-btn" id="toggle-gripper" onclick="toggleGripper()">ü§è Gripper</button>
                            <button class="viewer-btn" id="toggle-all" onclick="toggleAllGrasps()">üìä All Grasps</button>
                            <button class="viewer-btn" id="toggle-wireframe" onclick="toggleWireframe()">üîó Wireframe</button>
                        </div>
                        <div class="viewer-info">
                            <div>üñ±Ô∏è Left Click + Drag: Rotate</div>
                            <div>üñ±Ô∏è Right Click + Drag: Pan</div>
                            <div>üñ±Ô∏è Scroll: Zoom</div>
                            <div id="point-count">Points: Loading...</div>
                        </div>
                        <div id="no-data-message" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(255,255,255,0.9); padding: 20px; border-radius: 8px;">
                            <h3>üìÅ No 3D Visualization Data Available</h3>
                            <p>This result doesn't contain compatible 3D visualization files.</p>
                            <p>You can still view the analysis results below.</p>
                        </div>
                    </div>

                    <!-- Multi-Panel View Container -->
                    <div id="multi-panel-container" style="display: none;">
                        <div id="multi-panel-loading" style="display: none; text-align: center; padding: 20px; background: rgba(255,255,255,0.9); border-radius: 8px; margin-bottom: 20px;">
                            <div style="font-size: 24px;">‚è≥</div>
                            <div>Loading all panels...</div>
                            <div id="loading-progress" style="margin-top: 10px; color: #666;"></div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                            <div class="panel-viewer" id="panel-1">
                                <h4 style="text-align: center; margin-bottom: 10px;">
                                    Step 1: Initial Grasps
                                    <button class="viewer-btn" onclick="synchronizeCameras()" style="margin-left: 10px; padding: 3px 8px; font-size: 11px;" title="Sync all camera views to match this panel">
                                        üîó Sync All
                                    </button>
                                </h4>
                                <div class="viewer-container panel-container" style="height: 400px; position: relative;">
                                    <div class="viewer-info panel-info" style="font-size: 10px;">
                                        <div id="panel-1-count">Points: Loading...</div>
                                        <div style="margin-top: 5px; color: #ffeb3b;">üìå Main View (others sync to this)</div>
                                    </div>
                                </div>
                            </div>
                            <div class="panel-viewer" id="panel-2">
                                <h4 style="text-align: center; margin-bottom: 10px;">Step 2: After Mask Filter</h4>
                                <div class="viewer-container panel-container" style="height: 400px; position: relative;">
                                    <div class="viewer-info panel-info" style="font-size: 10px;">
                                        <div id="panel-2-count">Points: Loading...</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <div class="panel-viewer" id="panel-3">
                                <h4 style="text-align: center; margin-bottom: 10px;">Step 3: Final Grasps</h4>
                                <div class="viewer-container panel-container" style="height: 400px; position: relative;">
                                    <div class="viewer-info panel-info" style="font-size: 10px;">
                                        <div id="panel-3-count">Points: Loading...</div>
                                    </div>
                                </div>
                            </div>
                            <div class="panel-viewer" id="panel-4">
                                <h4 style="text-align: center; margin-bottom: 10px;">Step 4: Selected Result</h4>
                                <div class="viewer-container panel-container" style="height: 400px; position: relative;">
                                    <div class="viewer-info panel-info" style="font-size: 10px;">
                                        <div id="panel-4-count">Points: Loading...</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div style="text-align: center; margin-top: 15px;">
                            <button class="viewer-btn" onclick="resetAllCameras()">üîÑ Reset All Views</button>
                            <button class="viewer-btn" onclick="toggleAutoSync()" id="auto-sync-btn">üîÑ Auto-Sync: OFF</button>
                        </div>
                        <div style="margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                            <h5 style="margin-bottom: 10px;">üí° Multi-Panel Navigation Tips:</h5>
                            <ul style="margin: 0; padding-left: 20px; font-size: 12px; line-height: 1.6;">
                                <li><strong>Panel 1 is the main view</strong> - Other panels sync to its camera position</li>
                                <li><strong>Click "Sync All"</strong> next to Panel 1 to align all camera views</li>
                                <li><strong>Enable "Auto-Sync"</strong> to keep all panels synchronized while navigating</li>
                                <li><strong>Mouse Controls:</strong> Left-drag to rotate, Right-drag to pan, Scroll to zoom</li>
                                <li><strong>Reset All Views</strong> returns all cameras to default positions</li>
                                <li>Each panel shows: Point cloud (blue dots) + Grasp poses (colored meshes)</li>
                                <li>Grasp colors: üü¢ Green = Low score, üî¥ Red = High score</li>
                            </ul>
                        </div>
                    </div>

                    <div class="info-grid">
                        <div class="info-card">
                            <h4>üß† OpenAI Analysis</h4>
                            <pre>${openaiResponse || 'Not available'}</pre>
                        </div>
                        <div class="info-card">
                            <h4>üìã Final Results</h4>
                            <pre>${JSON.stringify(finalResults, null, 2)}</pre>
                        </div>
                    </div>
                `;

                document.getElementById('content').innerHTML = content;
                
                // Show steps selector if available
                if (availableSteps && availableSteps.length > 0) {
                    showStepsSelector();
                } else {
                    // Hide steps selector for legacy results
                    const selector = document.getElementById('steps-selector');
                    if (selector) {
                        selector.style.display = 'none';
                    }
                }
                
                // Initialize 3D viewer with final results first
                setTimeout(() => init3DViewer(timestamp), 100);
                
            } catch (error) {
                console.error('Error loading result:', error);
                document.getElementById('content').innerHTML = `<div class="error-message">Error loading result: ${error.message}</div>`;
            }
        }

        // Helper functions to load files
        async function loadTextFile(timestamp, filename) {
            try {
                const response = await fetch(`/results/${timestamp}/${filename}`);
                return await response.text();
            } catch (error) {
                console.warn(`Could not load ${filename}:`, error);
                return null;
            }
        }

        async function loadJsonFile(timestamp, filename, required = true) {
            try {
                const response = await fetch(`/results/${timestamp}/${filename}`);
                return await response.json();
            } catch (error) {
                if (required) {
                    console.error(`Could not load ${filename}:`, error);
                }
                return null;
            }
        }

        async function loadSteps(timestamp) {
            try {
                const response = await fetch(`/steps/${timestamp}`);
                
                if (!response.ok) {
                    console.warn(`Steps endpoint returned ${response.status} for ${timestamp}`);
                    return { steps: [] };
                }
                
                const data = await response.json();
                return data;
            } catch (error) {
                console.warn(`Could not load steps for ${timestamp}:`, error);
                return { steps: [] };
            }
        }

        function showStepsSelector() {
            const selector = document.getElementById('steps-selector');
            const buttonsContainer = document.getElementById('steps-buttons');
            
            // Create step buttons
            let buttonsHtml = '<button class="viewer-btn" onclick="loadFinalResults()">üéØ Final Results</button>';
            
            availableSteps.forEach(step => {
                const stepName = step.step_name.replace(/_/g, ' ').replace(/^\d+\s+/, '');
                buttonsHtml += `<button class="viewer-btn" onclick="loadStep('${step.folder}')">${stepName} (${step.num_grasps})</button>`;
            });
            
            buttonsContainer.innerHTML = buttonsHtml;
            selector.style.display = 'block';
        }

        async function loadStep(stepFolder) {
            if (!currentResult) return;
            
            // Update button states
            document.querySelectorAll('#steps-buttons .viewer-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            currentStep = stepFolder;
            
            // Clear current 3D scene
            if (scene) {
                clearScene();
            }
            
            // Load step data
            try {
                await loadStepPointCloud(currentResult, stepFolder);
                await loadStepGrasps(currentResult, stepFolder);
                
                document.getElementById('point-count').textContent = 'Points: Loading step data...';
                
            } catch (error) {
                console.error('Error loading step:', error);
            }
        }

        function loadFinalResults() {
            // Update button states
            document.querySelectorAll('#steps-buttons .viewer-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            currentStep = null;
            
            // Clear current 3D scene
            if (scene) {
                clearScene();
            }
            
            // Load final results
            loadPointCloud(currentResult);
            loadGripper(currentResult);
            loadAllGrasps(currentResult);
        }

        // 3D Viewer Functions
        function init3DViewer(timestamp) {
            const container = document.getElementById('threejs-viewer');
            if (!container) return;
            
            // Clear previous scene safely
            if (renderer && renderer.domElement && renderer.domElement.parentNode === container) {
                container.removeChild(renderer.domElement);
            }
            
            // Clear any existing renderers
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 5);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // Controls setup
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Reset arrays
            allGraspMeshes = [];
            pointCloud = null;
            gripperMesh = null;
            
            // Load 3D data
            loadPointCloud(timestamp);
            loadGripper(timestamp);
            loadAllGrasps(timestamp);
            
            // Start render loop
            animate();
        }

        async function loadPointCloud(timestamp) {
            try {
                const response = await fetch(`/results/${timestamp}/point_cloud.json`);
                
                if (!response.ok) {
                    throw new Error(`Point cloud JSON not found (${response.status}). This may be an older result.`);
                }
                
                const data = await response.json();
                
                if (!data || !data.points || !Array.isArray(data.points)) {
                    throw new Error('Invalid point cloud data format');
                }
                
                // Create geometry from JSON data
                const geometry = new THREE.BufferGeometry();
                
                // Convert points to Float32Array
                const positions = new Float32Array(data.points.flat());
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                // Add colors if available
                if (data.colors && data.colors.length > 0 && Array.isArray(data.colors)) {
                    const colors = new Float32Array(data.colors.flat());
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                }
                
                // Create point cloud material
                const material = new THREE.PointsMaterial({ 
                    size: 0.005, 
                    vertexColors: data.colors && data.colors.length > 0,
                    sizeAttenuation: true,
                    color: data.colors && data.colors.length > 0 ? 0xffffff : 0x4169e1
                });
                
                pointCloud = new THREE.Points(geometry, material);
                scene.add(pointCloud);
                
                // Update point count
                const pointCountEl = document.getElementById('point-count');
                if (pointCountEl) {
                    pointCountEl.textContent = `Points: ${data.count || data.points.length}`;
                }
                
                // Center camera on point cloud
                geometry.computeBoundingBox();
                const box = geometry.boundingBox;
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                controls.target.copy(center);
                camera.position.copy(center);
                camera.position.z += Math.max(size.x, size.y, size.z) * 2;
                camera.lookAt(center);
                
            } catch (error) {
                console.warn('Point cloud JSON not available:', error.message);
                
                const pointCountEl = document.getElementById('point-count');
                
                // Try to convert PLY file on-the-fly for legacy results
                try {
                    const convertResponse = await fetch(`/convert_ply/${timestamp}/cloud.ply`);
                    if (convertResponse.ok) {
                        const data = await convertResponse.json();
                        
                        // Create geometry from converted data
                        const geometry = new THREE.BufferGeometry();
                        const positions = new Float32Array(data.points.flat());
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        
                        if (data.colors && data.colors.length > 0) {
                            const colors = new Float32Array(data.colors.flat());
                            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                        }
                        
                        const material = new THREE.PointsMaterial({ 
                            size: 0.005, 
                            vertexColors: data.colors && data.colors.length > 0,
                            sizeAttenuation: true,
                            color: data.colors && data.colors.length > 0 ? 0xffffff : 0x4169e1
                        });
                        
                        pointCloud = new THREE.Points(geometry, material);
                        scene.add(pointCloud);
                        
                        if (pointCountEl) {
                            pointCountEl.textContent = `Points: ${data.count} (converted from PLY)`;
                        }
                        
                        // Center camera
                        geometry.computeBoundingBox();
                        const box = geometry.boundingBox;
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        
                        controls.target.copy(center);
                        camera.position.copy(center);
                        camera.position.z += Math.max(size.x, size.y, size.z) * 2;
                        camera.lookAt(center);
                        
                        return; // Success, exit function
                    }
                } catch (convertError) {
                    console.warn('PLY conversion also failed:', convertError.message);
                }
                
                // Last resort - show download link or message
                if (pointCountEl) {
                    // Check if PLY file might exist
                    fetch(`/results/${timestamp}/cloud.ply`, { method: 'HEAD' })
                        .then(response => {
                            if (response.ok) {
                                pointCountEl.innerHTML = 'Points: <a href="/results/' + timestamp + '/cloud.ply" target="_blank">Download PLY file</a>';
                            } else {
                                pointCountEl.textContent = 'Points: No point cloud data available';
                                showNoDataMessage();
                            }
                        })
                        .catch(() => {
                            pointCountEl.textContent = 'Points: No point cloud data available';
                            showNoDataMessage();
                        });
                }
            }
        }

        async function loadGripper(timestamp) {
            try {
                const response = await fetch(`/results/${timestamp}/chosen_grasp.json`);
                
                if (!response.ok) {
                    throw new Error(`Chosen grasp JSON not found (${response.status}). This may be an older result.`);
                }
                
                const data = await response.json();
                
                if (!data || !data.vertices || !data.faces) {
                    throw new Error('Invalid gripper data format');
                }
                
                // Create geometry from JSON data
                const geometry = new THREE.BufferGeometry();
                
                // Convert vertices to Float32Array
                const vertices = new Float32Array(data.vertices.flat());
                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                
                // Convert faces to indices
                const indices = new Uint16Array(data.faces.flat());
                geometry.setIndex(new THREE.BufferAttribute(indices, 1));
                
                // Compute normals for proper lighting
                geometry.computeVertexNormals();
                
                // Create gripper material
                const material = new THREE.MeshLambertMaterial({ 
                    color: 0xff6b6b,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                
                gripperMesh = new THREE.Mesh(geometry, material);
                gripperMesh.castShadow = true;
                scene.add(gripperMesh);
                
            } catch (error) {
                console.warn('Chosen grasp JSON not available:', error.message);
                // Silently continue - this is expected for older results
            }
        }

        async function loadAllGrasps(timestamp) {
            try {
                const response = await fetch(`/results/${timestamp}/all_grasps.json`);
                
                if (!response.ok) {
                    throw new Error(`All grasps JSON not found (${response.status}). This may be an older result.`);
                }
                
                const data = await response.json();
                
                if (!data || !data.grasps || !Array.isArray(data.grasps)) {
                    throw new Error('Invalid all grasps data format');
                }
                
                data.grasps.forEach((graspData, index) => {
                    if (!graspData.vertices || !graspData.faces) {
                        console.warn(`Skipping grasp ${index} - invalid data`);
                        return;
                    }
                    
                    // Create geometry from JSON data
                    const geometry = new THREE.BufferGeometry();
                    
                    // Convert vertices to Float32Array
                    const vertices = new Float32Array(graspData.vertices.flat());
                    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                    
                    // Convert faces to indices
                    const indices = new Uint16Array(graspData.faces.flat());
                    geometry.setIndex(new THREE.BufferAttribute(indices, 1));
                    
                    // Compute normals for proper lighting
                    geometry.computeVertexNormals();
                    
                    // Create material - selected grasp is red, others are blue/transparent
                    const material = new THREE.MeshLambertMaterial({ 
                        color: graspData.selected ? 0xff6b6b : 0x4169e1,
                        transparent: true,
                        opacity: graspData.selected ? 0.8 : 0.3,
                        side: THREE.DoubleSide
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.castShadow = true;
                    mesh.visible = false; // Initially hidden
                    scene.add(mesh);
                    allGraspMeshes.push(mesh);
                });
                
                console.log(`Loaded ${data.grasps.length} grasp poses`);
                
            } catch (error) {
                console.warn('All grasps JSON not available:', error.message);
                // Silently continue - this is expected for older results
            }
        }

        async function loadStepPointCloud(timestamp, stepFolder) {
            try {
                const response = await fetch(`/step_files/${timestamp}/${stepFolder}/point_cloud.json`);
                const data = await response.json();
                
                // Create geometry from JSON data
                const geometry = new THREE.BufferGeometry();
                
                // Convert points to Float32Array
                const positions = new Float32Array(data.points.flat());
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                // Add colors if available
                if (data.colors && data.colors.length > 0) {
                    const colors = new Float32Array(data.colors.flat());
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                }
                
                // Create point cloud material
                const material = new THREE.PointsMaterial({ 
                    size: 0.005, 
                    vertexColors: data.colors && data.colors.length > 0,
                    sizeAttenuation: true,
                    color: data.colors && data.colors.length > 0 ? 0xffffff : 0x4169e1
                });
                
                pointCloud = new THREE.Points(geometry, material);
                scene.add(pointCloud);
                
                // Update point count
                const pointCountEl = document.getElementById('point-count');
                if (pointCountEl) {
                    pointCountEl.textContent = `Points: ${data.count}`;
                }
                
                // Center camera on point cloud
                geometry.computeBoundingBox();
                const box = geometry.boundingBox;
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                controls.target.copy(center);
                camera.position.copy(center);
                camera.position.z += Math.max(size.x, size.y, size.z) * 2;
                camera.lookAt(center);
                
            } catch (error) {
                console.error('Error loading step point cloud:', error);
                const pointCountEl = document.getElementById('point-count');
                if (pointCountEl) {
                    pointCountEl.textContent = 'Points: Failed to load';
                }
            }
        }

        async function loadStepGrasps(timestamp, stepFolder) {
            try {
                const response = await fetch(`/step_files/${timestamp}/${stepFolder}/metadata.json`);
                const metadata = await response.json();
                
                // Load all grasps for this step
                metadata.grasps.forEach((graspData, index) => {
                    // Create geometry from JSON data
                    const geometry = new THREE.BufferGeometry();
                    
                    // Convert vertices to Float32Array
                    const vertices = new Float32Array(graspData.vertices.flat());
                    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                    
                    // Convert faces to indices
                    const indices = new Uint16Array(graspData.faces.flat());
                    geometry.setIndex(new THREE.BufferAttribute(indices, 1));
                    
                    // Compute normals for proper lighting
                    geometry.computeVertexNormals();
                    
                    // Color based on score - higher scores are more red
                    const score = graspData.score || 0;
                    const normalizedScore = Math.max(0, Math.min(1, score));
                    const color = new THREE.Color().setHSL(0.33 * (1 - normalizedScore), 0.8, 0.5); // Green to red
                    
                    const material = new THREE.MeshLambertMaterial({ 
                        color: color,
                        transparent: true,
                        opacity: 0.7,
                        side: THREE.DoubleSide
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.castShadow = true;
                    scene.add(mesh);
                    allGraspMeshes.push(mesh);
                });
                
                console.log(`Loaded ${metadata.grasps.length} grasps for step ${stepFolder}`);
                
            } catch (error) {
                console.error('Error loading step grasps:', error);
            }
        }

        function clearScene() {
            if (!scene) return;
            
            // Remove point cloud
            if (pointCloud) {
                scene.remove(pointCloud);
                pointCloud = null;
            }
            
            // Remove gripper mesh
            if (gripperMesh) {
                scene.remove(gripperMesh);
                gripperMesh = null;
            }
            
            // Remove all grasp meshes
            if (allGraspMeshes && Array.isArray(allGraspMeshes)) {
                allGraspMeshes.forEach(mesh => {
                    if (mesh && scene) {
                        scene.remove(mesh);
                    }
                });
            }
            allGraspMeshes = [];
            
            // Hide no data message
            hideNoDataMessage();
        }

        function showNoDataMessage() {
            const message = document.getElementById('no-data-message');
            if (message) {
                message.style.display = 'block';
            }
        }

        function hideNoDataMessage() {
            const message = document.getElementById('no-data-message');
            if (message) {
                message.style.display = 'none';
            }
        }

        // Control functions
        function resetCamera() {
            if (pointCloud) {
                const box = new THREE.Box3().setFromObject(pointCloud);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                controls.target.copy(center);
                camera.position.copy(center);
                camera.position.z += Math.max(size.x, size.y, size.z) * 2;
                camera.lookAt(center);
                controls.update();
            }
        }

        function togglePointCloud() {
            if (pointCloud) {
                showPointCloud = !showPointCloud;
                pointCloud.visible = showPointCloud;
                const btn = document.getElementById('toggle-points');
                if (btn) btn.classList.toggle('active');
            }
        }

        function toggleGripper() {
            if (gripperMesh) {
                showGripper = !showGripper;
                gripperMesh.visible = showGripper;
                const btn = document.getElementById('toggle-gripper');
                if (btn) btn.classList.toggle('active');
            }
        }

        function toggleAllGrasps() {
            showAllGrasps = !showAllGrasps;
            
            if (allGraspMeshes && Array.isArray(allGraspMeshes)) {
                allGraspMeshes.forEach(mesh => {
                    if (mesh) {
                        mesh.visible = showAllGrasps;
                    }
                });
            }
            
            // Hide individual gripper when showing all grasps
            if (gripperMesh && showAllGrasps) {
                gripperMesh.visible = false;
                showGripper = false;
                const gripperBtn = document.getElementById('toggle-gripper');
                if (gripperBtn) gripperBtn.classList.remove('active');
            }
            
            const btn = document.getElementById('toggle-all');
            if (btn) btn.classList.toggle('active');
        }

        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            
            if (gripperMesh && gripperMesh.material) {
                gripperMesh.material.wireframe = wireframeMode;
            }
            
            if (allGraspMeshes && Array.isArray(allGraspMeshes)) {
                allGraspMeshes.forEach(mesh => {
                    if (mesh && mesh.material) {
                        mesh.material.wireframe = wireframeMode;
                    }
                });
            }
            
            const btn = document.getElementById('toggle-wireframe');
            if (btn) btn.classList.toggle('active');
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) {
                controls.update();
            }
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // Multi-panel functions
        function showSingleView() {
            isMultiPanelMode = false;
            document.getElementById('threejs-viewer').style.display = 'block';
            document.getElementById('multi-panel-container').style.display = 'none';
            document.getElementById('single-view-btn').classList.add('active');
            document.getElementById('multi-panel-btn').classList.remove('active');
        }

        async function showMultiPanel() {
            if (!availableSteps || availableSteps.length === 0) {
                alert('Multi-panel view requires intermediate steps data. This result doesn\'t have step-by-step data.');
                return;
            }
            
            isMultiPanelMode = true;
            document.getElementById('threejs-viewer').style.display = 'none';
            document.getElementById('multi-panel-container').style.display = 'block';
            document.getElementById('single-view-btn').classList.remove('active');
            document.getElementById('multi-panel-btn').classList.add('active');
            
            // Show loading indicator
            const loadingDiv = document.getElementById('multi-panel-loading');
            if (loadingDiv) {
                loadingDiv.style.display = 'block';
            }
            
            // Initialize all panels after a brief delay
            setTimeout(async () => {
                await initializeAllPanels();
                // Hide loading indicator
                if (loadingDiv) {
                    loadingDiv.style.display = 'none';
                }
            }, 100);
        }

        async function initializeAllPanels() {
            const stepMapping = {
                1: '01_initial_grasps',
                2: '02_after_mask_filter', 
                3: '03_final_grasps',
                4: 'final_result'
            };

            // Show loading indicators for all panels
            for (let i = 1; i <= 4; i++) {
                const container = document.querySelector(`#panel-${i} .panel-container`);
                if (container) {
                    container.innerHTML = '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #666;"><div style="font-size: 24px;">‚è≥</div><div>Loading...</div></div>';
                }
            }

            // Initialize all panels in parallel
            const initPromises = [];
            for (let i = 1; i <= 4; i++) {
                initPromises.push(initializePanel(i, stepMapping[i]));
            }
            
            // Wait for all panels to initialize
            await Promise.all(initPromises);
        }

        async function initializePanel(panelNum, stepFolder) {
            const container = document.querySelector(`#panel-${panelNum} .panel-container`);
            if (!container) return;

            // Clear existing content but keep info panel
            const infoPanel = container.querySelector('.viewer-info');
            container.innerHTML = '';
            if (infoPanel) {
                container.appendChild(infoPanel);
            }

            // Create Three.js scene for this panel
            const panelScene = new THREE.Scene();
            panelScene.background = new THREE.Color(0xf5f5f5);
            
            const panelCamera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            panelCamera.position.set(0, 0, 5);
            
            const panelRenderer = new THREE.WebGLRenderer({ antialias: true });
            panelRenderer.setSize(container.clientWidth, container.clientHeight);
            panelRenderer.shadowMap.enabled = true;
            panelRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(panelRenderer.domElement);
            
            const panelControls = new THREE.OrbitControls(panelCamera, panelRenderer.domElement);
            panelControls.enableDamping = true;
            panelControls.dampingFactor = 0.05;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            panelScene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            panelScene.add(directionalLight);

            // Store panel data
            panels[panelNum] = {
                scene: panelScene,
                camera: panelCamera,
                renderer: panelRenderer,
                controls: panelControls,
                container: container,
                stepFolder: stepFolder
            };

            // Load data for this panel (return promise for parallel loading)
            const loadPromise = (stepFolder === 'final_result') 
                ? loadPanelFinalResult(panelNum)
                : loadPanelStepData(panelNum, stepFolder);

            // Start animation for this panel
            animatePanel(panelNum);
            
            // Return the load promise so we can wait for it
            return loadPromise;
        }

        async function loadPanelStepData(panelNum, stepFolder) {
            const panel = panels[panelNum];
            if (!panel || !currentResult) return;

            try {
                // Check cache first
                const cacheKey = `${currentResult}_${stepFolder}`;
                let pointCloudData = cachedPointCloudData[cacheKey];
                let pointCloudSource = 'cached';
                
                if (!pointCloudData) {
                    // First try to load point cloud from the step folder
                    pointCloudSource = 'step';
                    
                    try {
                        const stepResponse = await fetch(`/step_files/${currentResult}/${stepFolder}/point_cloud.json`);
                        if (stepResponse.ok) {
                            pointCloudData = await stepResponse.json();
                            cachedPointCloudData[cacheKey] = pointCloudData;
                        }
                    } catch (stepError) {
                        console.warn(`Step point cloud not found for ${stepFolder}, trying main result`);
                    }
                    
                    // Fallback to main result point cloud if step point cloud not available
                    if (!pointCloudData) {
                        // Check if main cloud is already cached
                        const mainCacheKey = `${currentResult}_main`;
                        pointCloudData = cachedPointCloudData[mainCacheKey];
                        
                        if (!pointCloudData) {
                            try {
                                const mainResponse = await fetch(`/results/${currentResult}/point_cloud.json`);
                                if (mainResponse.ok) {
                                    pointCloudData = await mainResponse.json();
                                    cachedPointCloudData[mainCacheKey] = pointCloudData;
                                    pointCloudSource = 'main';
                                }
                            } catch (mainError) {
                                console.warn(`Main point cloud not found either, trying PLY conversion`);
                                // Try PLY conversion as last resort
                                try {
                                    const plyResponse = await fetch(`/convert_ply/${currentResult}/cloud.ply`);
                                    if (plyResponse.ok) {
                                        pointCloudData = await plyResponse.json();
                                        cachedPointCloudData[mainCacheKey] = pointCloudData;
                                        pointCloudSource = 'converted';
                                    }
                                } catch (plyError) {
                                    console.error(`No point cloud available for panel ${panelNum}`);
                                }
                            }
                        } else {
                            pointCloudSource = 'main (cached)';
                        }
                    }
                }
                
                // Add point cloud if we found one
                if (pointCloudData) {
                    const pointCloud = createPointCloudFromData(pointCloudData);
                    panel.scene.add(pointCloud);
                    
                    // Update count with source info
                    const countEl = document.getElementById(`panel-${panelNum}-count`);
                    if (countEl) {
                        const sourceLabel = pointCloudSource === 'step' ? '' : ` (${pointCloudSource})`;
                        countEl.textContent = `Points: ${pointCloudData.count}${sourceLabel}`;
                    }
                    
                    // Center camera
                    centerCameraOnObject(panel.camera, panel.controls, pointCloud);
                } else {
                    // No point cloud available
                    const countEl = document.getElementById(`panel-${panelNum}-count`);
                    if (countEl) countEl.textContent = `Points: No data available`;
                }

                // Load grasps metadata
                const metaResponse = await fetch(`/step_files/${currentResult}/${stepFolder}/metadata.json`);
                if (metaResponse.ok) {
                    const metadata = await metaResponse.json();
                    
                    // Update count with grasp info
                    const countEl = document.getElementById(`panel-${panelNum}-count`);
                    if (countEl && pointCloudData) {
                        const sourceLabel = pointCloudSource === 'step' ? '' : ` (${pointCloudSource})`;
                        countEl.textContent = `Points: ${pointCloudData.count}${sourceLabel} | Grasps: ${metadata.grasps.length}`;
                    }
                    
                    metadata.grasps.forEach((graspData, index) => {
                        const mesh = createGraspMeshFromData(graspData, index);
                        panel.scene.add(mesh);
                    });
                } else {
                    console.warn(`No metadata found for step ${stepFolder}`);
                    // Update count to show no grasps
                    const countEl = document.getElementById(`panel-${panelNum}-count`);
                    if (countEl && pointCloudData) {
                        const sourceLabel = pointCloudSource === 'step' ? '' : ` (${pointCloudSource})`;
                        countEl.textContent = `Points: ${pointCloudData.count}${sourceLabel} | Grasps: 0`;
                    }
                }
            } catch (error) {
                console.error(`Error loading panel ${panelNum} data:`, error);
                const countEl = document.getElementById(`panel-${panelNum}-count`);
                if (countEl) countEl.textContent = `Error loading data`;
            }
        }

        async function loadPanelFinalResult(panelNum) {
            const panel = panels[panelNum];
            if (!panel || !currentResult) return;

            try {
                // Load final point cloud
                const response = await fetch(`/results/${currentResult}/point_cloud.json`);
                if (response.ok) {
                    const data = await response.json();
                    const pointCloud = createPointCloudFromData(data);
                    panel.scene.add(pointCloud);
                    
                    const countEl = document.getElementById(`panel-${panelNum}-count`);
                    if (countEl) countEl.textContent = `Points: ${data.count}`;
                    
                    centerCameraOnObject(panel.camera, panel.controls, pointCloud);
                }

                // Load selected grasp
                const graspResponse = await fetch(`/results/${currentResult}/chosen_grasp.json`);
                if (graspResponse.ok) {
                    const graspData = await graspResponse.json();
                    const mesh = createSelectedGraspMesh(graspData);
                    panel.scene.add(mesh);
                }
            } catch (error) {
                console.error(`Error loading panel ${panelNum} final result:`, error);
            }
        }

        function createPointCloudFromData(data) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(data.points.flat());
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            if (data.colors && data.colors.length > 0) {
                const colors = new Float32Array(data.colors.flat());
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            }
            
            const material = new THREE.PointsMaterial({ 
                size: 0.005, 
                vertexColors: data.colors && data.colors.length > 0,
                sizeAttenuation: true,
                color: data.colors && data.colors.length > 0 ? 0xffffff : 0x4169e1
            });
            
            return new THREE.Points(geometry, material);
        }

        function createGraspMeshFromData(graspData, index) {
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array(graspData.vertices.flat());
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            
            const indices = new Uint16Array(graspData.faces.flat());
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            geometry.computeVertexNormals();
            
            // Color based on score
            const score = graspData.score || 0;
            const normalizedScore = Math.max(0, Math.min(1, score));
            const color = new THREE.Color().setHSL(0.33 * (1 - normalizedScore), 0.8, 0.5);
            
            const material = new THREE.MeshLambertMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            
            return new THREE.Mesh(geometry, material);
        }

        function createSelectedGraspMesh(graspData) {
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array(graspData.vertices.flat());
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            
            const indices = new Uint16Array(graspData.faces.flat());
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshLambertMaterial({ 
                color: 0xff6b6b,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            
            return new THREE.Mesh(geometry, material);
        }

        function centerCameraOnObject(camera, controls, object) {
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            controls.target.copy(center);
            camera.position.copy(center);
            camera.position.z += Math.max(size.x, size.y, size.z) * 2;
            camera.lookAt(center);
            controls.update();
        }

        function animatePanel(panelNum) {
            const panel = panels[panelNum];
            if (!panel) return;
            
            function animate() {
                requestAnimationFrame(animate);
                panel.controls.update();
                
                // Auto-sync if enabled and this is panel 1
                if (autoSync && panelNum === 1) {
                    synchronizeCamerasFromPanel1();
                }
                
                panel.renderer.render(panel.scene, panel.camera);
            }
            animate();
        }

        function synchronizeCameras() {
            if (!isMultiPanelMode) return;
            synchronizeCamerasFromPanel1();
        }
        
        function synchronizeCamerasFromPanel1() {
            // Use panel 1 as reference
            const refPanel = panels[1];
            if (!refPanel) return;
            
            const refPosition = refPanel.camera.position.clone();
            const refTarget = refPanel.controls.target.clone();
            
            // Apply to all other panels
            for (let i = 2; i <= 4; i++) {
                const panel = panels[i];
                if (panel) {
                    panel.camera.position.copy(refPosition);
                    panel.controls.target.copy(refTarget);
                    panel.camera.lookAt(refTarget);
                    panel.controls.update();
                }
            }
        }
        
        function toggleAutoSync() {
            autoSync = !autoSync;
            const btn = document.getElementById('auto-sync-btn');
            if (btn) {
                btn.textContent = autoSync ? 'üîÑ Auto-Sync: ON' : 'üîÑ Auto-Sync: OFF';
                btn.style.background = autoSync ? 'rgba(76, 175, 80, 0.9)' : 'rgba(102, 126, 234, 0.9)';
            }
            
            // If turning on auto-sync, immediately sync cameras
            if (autoSync) {
                synchronizeCameras();
            }
        }

        function resetAllCameras() {
            if (!isMultiPanelMode) return;
            
            for (let i = 1; i <= 4; i++) {
                const panel = panels[i];
                if (panel) {
                    panel.camera.position.set(0, 0, 5);
                    panel.controls.target.set(0, 0, 0);
                    panel.camera.lookAt(0, 0, 0);
                    panel.controls.update();
                }
            }
        }

        // Handle window resize
        window.addEventListener('resize', function() {
            if (isMultiPanelMode) {
                Object.values(panels).forEach(panel => {
                    if (panel.container && panel.camera && panel.renderer) {
                        panel.camera.aspect = panel.container.clientWidth / panel.container.clientHeight;
                        panel.camera.updateProjectionMatrix();
                        panel.renderer.setSize(panel.container.clientWidth, panel.container.clientHeight);
                    }
                });
            } else {
                const container = document.getElementById('threejs-viewer');
                if (container && camera && renderer) {
                    camera.aspect = container.clientWidth / container.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(container.clientWidth, container.clientHeight);
                }
            }
        });

        // Initialize on page load
        window.addEventListener('load', function() {
            loadResultsList();
        });
    </script>
</body>
</html>